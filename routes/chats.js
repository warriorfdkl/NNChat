const express = require('express');
const { body, query, validationResult } = require('express-validator');
const Chat = require('../models/Chat');
const ChatParticipant = require('../models/ChatParticipant');
const User = require('../models/User');
const VitroCADFile = require('../models/VitroCADFile');
const { authenticateToken, checkChatPermission, checkChatExists } = require('../middleware/auth');
const { sendToChat } = require('../services/socketService');
const emailBasedSync = require('../services/emailBasedSync');
const { Op } = require('sequelize');

const router = express.Router();

// –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —á–∞—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
router.get('/', authenticateToken, [
  query('limit')
    .optional()
    .isInt({ min: 1, max: 100 })
    .withMessage('Limit must be between 1 and 100'),
  query('offset')
    .optional()
    .isInt({ min: 0 })
    .withMessage('Offset must be non-negative')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        error: 'Validation failed', 
        details: errors.array() 
      });
    }
    
    const userId = req.userId;
    const limit = parseInt(req.query.limit) || 50;
    const offset = parseInt(req.query.offset) || 0;
    
    // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ email
    const user = await User.findByPk(userId);
    
    let chatFilter = { is_active: true };
    
    // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å VitroCAD —Å email, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –µ–≥–æ —á–∞—Ç—ã
    if (user && user.is_vitrocad_user && user.email) {
      // –ü–æ–ª—É—á–∞–µ–º —Ñ–∞–π–ª—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      const userFiles = await VitroCADFile.findAll({
        where: {
          author_id: userId,
          is_active: true
        },
        attributes: ['id']
      });
      
      const userFileIds = userFiles.map(file => file.id);
      
      // –§–∏–ª—å—Ç—Ä—É–µ–º —á–∞—Ç—ã: –ª–∏–±–æ —Å–æ–∑–¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º, –ª–∏–±–æ —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å –µ–≥–æ —Ñ–∞–π–ª–∞–º–∏
      chatFilter = {
        is_active: true,
        [Op.or]: [
          { created_by: userId },
          { vitrocad_file_id: { [Op.in]: userFileIds } }
        ]
      };
    }
    
    const chatParticipants = await ChatParticipant.findAll({
      where: { user_id: userId },
      include: [{
        model: Chat,
        as: 'chat',
        where: chatFilter,
        include: [{
          model: VitroCADFile,
          as: 'vitrocadFile',
          required: false,
          attributes: ['id', 'name', 'file_type', 'status', 'author_id']
        }]
      }],
      order: [
        ['is_pinned', 'DESC'],
        [{ model: Chat, as: 'chat' }, 'last_message_at', 'DESC']
      ],
      limit: limit,
      offset: offset
    });
    
    const chats = await Promise.all(chatParticipants.map(async (participant) => {
      const chat = participant.chat;
      const unreadCount = await participant.getUnreadCount();
      
      return {
        id: chat.id,
        name: chat.name,
        description: chat.description,
        type: chat.type,
        last_message_at: chat.last_message_at,
        last_message_text: chat.last_message_text,
        unread_count: unreadCount,
        is_pinned: participant.is_pinned,
        is_muted: participant.is_muted,
        participant_role: participant.role,
        vitrocad_file: chat.vitrocadFile ? {
          id: chat.vitrocadFile.id,
          name: chat.vitrocadFile.name,
          vitrocad_id: chat.vitrocadFile.vitrocad_id
        } : null,
        is_user_file: chat.vitrocadFile && chat.vitrocadFile.author_id === userId
      };
    }));
    
    res.json({
      chats: chats,
      user_info: {
        is_vitrocad_user: user ? user.is_vitrocad_user : false,
        email: user ? user.email : null,
        vitrocad_id: user ? user.vitrocad_id : null
      },
      total: chats.length,
      limit: limit,
      offset: offset
    });
  } catch (error) {
    console.error('Get chats error:', error);
    res.status(500).json({ error: 'Failed to get chats' });
  }
});

// –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º —á–∞—Ç–µ
router.get('/:chatId', authenticateToken, checkChatExists, checkChatPermission(), async (req, res) => {
  try {
    const chat = req.chat;
    const participant = req.chatParticipant;
    
    // –ü–æ–ª—É—á–∞–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —á–∞—Ç–∞
    const participants = await chat.getParticipants();
    
    // –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–æ–æ–±—â–µ–Ω–∏–π
    const Message = require('../models/Message');
    const messageStats = await Message.getMessageStats(chat.id);
    
    // –ü–æ–ª—É—á–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
    const unreadCount = await participant.getUnreadCount();
    
    res.json({
      id: chat.id,
      name: chat.name,
      description: chat.description,
      type: chat.type,
      created_by: chat.created_by,
      created_at: chat.created_at,
      last_message_at: chat.last_message_at,
      last_message_text: chat.last_message_text,
      settings: chat.settings,
      participants: participants.map(p => ({
        user: p.user.getPublicData(),
        role: p.role,
        joined_at: p.joined_at,
        last_read_at: p.last_read_at
      })),
      participant_info: {
        role: participant.role,
        joined_at: participant.joined_at,
        last_read_at: participant.last_read_at,
        is_muted: participant.is_muted,
        is_pinned: participant.is_pinned,
        unread_count: unreadCount
      },
      message_stats: messageStats,
      vitrocad_file: chat.vitrocadFile ? {
        id: chat.vitrocadFile.id,
        name: chat.vitrocadFile.name,
        vitrocad_id: chat.vitrocadFile.vitrocad_id,
        download_url: chat.vitrocadFile.getDownloadUrl()
      } : null
    });
  } catch (error) {
    console.error('Get chat error:', error);
    res.status(500).json({ error: 'Failed to get chat' });
  }
});

// –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —á–∞—Ç
router.post('/', authenticateToken, [
  body('name')
    .isLength({ min: 1, max: 255 })
    .withMessage('Chat name must be between 1 and 255 characters'),
  body('description')
    .optional()
    .isLength({ max: 1000 })
    .withMessage('Description must be less than 1000 characters'),
  body('type')
    .isIn(['group', 'direct'])
    .withMessage('Type must be either group or direct'),
  body('participants')
    .isArray({ min: 1 })
    .withMessage('At least one participant is required')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        error: 'Validation failed', 
        details: errors.array() 
      });
    }
    
    const { name, description, type, participants } = req.body;
    const userId = req.userId;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ —É—á–∞—Å—Ç–Ω–∏–∫–∏ —Å—É—â–µ—Å—Ç–≤—É—é—Ç
    const users = await User.findAll({
      where: {
        id: participants,
        is_active: true
      }
    });
    
    if (users.length !== participants.length) {
      return res.status(400).json({ error: 'Some participants not found or inactive' });
    }
    
    // –°–æ–∑–¥–∞–µ–º —á–∞—Ç
    const chat = await Chat.create({
      name: name,
      description: description,
      type: type,
      created_by: userId
    });
    
    // –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–∑–¥–∞—Ç–µ–ª—è –∫–∞–∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
    await chat.addParticipant(userId, 'admin');
    
    // –î–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
    for (const participantId of participants) {
      if (participantId !== userId) {
        await chat.addParticipant(participantId, 'member');
      }
    }
    
    // –£–≤–µ–¥–æ–º–ª—è–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —á–µ—Ä–µ–∑ WebSocket
    sendToChat(chat.id, 'chat_created', {
      chat: {
        id: chat.id,
        name: chat.name,
        type: chat.type,
        created_by: userId
      }
    });
    
    res.status(201).json({
      message: 'Chat created successfully',
      chat: {
        id: chat.id,
        name: chat.name,
        description: chat.description,
        type: chat.type,
        created_by: chat.created_by,
        created_at: chat.created_at
      }
    });
    
    console.log(`üí¨ Chat created: ${name} by ${req.user.username}`);
  } catch (error) {
    console.error('Create chat error:', error);
    res.status(500).json({ error: 'Failed to create chat' });
  }
});

// –û–±–Ω–æ–≤–∏—Ç—å —á–∞—Ç
router.put('/:chatId', authenticateToken, checkChatExists, checkChatPermission('admin'), [
  body('name')
    .optional()
    .isLength({ min: 1, max: 255 })
    .withMessage('Chat name must be between 1 and 255 characters'),
  body('description')
    .optional()
    .isLength({ max: 1000 })
    .withMessage('Description must be less than 1000 characters'),
  body('settings')
    .optional()
    .isObject()
    .withMessage('Settings must be an object')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        error: 'Validation failed', 
        details: errors.array() 
      });
    }
    
    const chat = req.chat;
    const { name, description, settings } = req.body;
    
    const updateData = {};
    if (name !== undefined) updateData.name = name;
    if (description !== undefined) updateData.description = description;
    if (settings !== undefined) {
      updateData.settings = { ...chat.settings, ...settings };
    }
    
    await chat.update(updateData);
    
    // –£–≤–µ–¥–æ–º–ª—è–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
    sendToChat(chat.id, 'chat_updated', {
      chat_id: chat.id,
      updates: updateData,
      updated_by: req.userId
    });
    
    res.json({
      message: 'Chat updated successfully',
      chat: {
        id: chat.id,
        name: chat.name,
        description: chat.description,
        settings: chat.settings
      }
    });
    
    console.log(`‚úèÔ∏è Chat updated: ${chat.name} by ${req.user.username}`);
  } catch (error) {
    console.error('Update chat error:', error);
    res.status(500).json({ error: 'Failed to update chat' });
  }
});

// –î–æ–±–∞–≤–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞ –≤ —á–∞—Ç
router.post('/:chatId/participants', authenticateToken, checkChatExists, checkChatPermission('moderator'), [
  body('user_id')
    .isUUID()
    .withMessage('Valid user ID is required'),
  body('role')
    .optional()
    .isIn(['member', 'moderator'])
    .withMessage('Role must be member or moderator')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        error: 'Validation failed', 
        details: errors.array() 
      });
    }
    
    const chat = req.chat;
    const { user_id, role = 'member' } = req.body;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    const user = await User.findByPk(user_id);
    if (!user || !user.is_active) {
      return res.status(404).json({ error: 'User not found or inactive' });
    }
    
    // –î–æ–±–∞–≤–ª—è–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞
    const { participant, created } = await chat.addParticipant(user_id, role);
    
    if (!created) {
      return res.status(409).json({ error: 'User is already a participant' });
    }
    
    // –£–≤–µ–¥–æ–º–ª—è–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
    sendToChat(chat.id, 'participant_added', {
      chat_id: chat.id,
      user: user.getPublicData(),
      role: role,
      added_by: req.userId
    });
    
    res.status(201).json({
      message: 'Participant added successfully',
      participant: {
        user: user.getPublicData(),
        role: role,
        joined_at: participant.joined_at
      }
    });
    
    console.log(`üë• User ${user.username} added to chat ${chat.name}`);
  } catch (error) {
    console.error('Add participant error:', error);
    res.status(500).json({ error: 'Failed to add participant' });
  }
});

// –£–¥–∞–ª–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞ –∏–∑ —á–∞—Ç–∞
router.delete('/:chatId/participants/:userId', authenticateToken, checkChatExists, checkChatPermission('moderator'), async (req, res) => {
  try {
    const chat = req.chat;
    const { userId } = req.params;
    const currentUserId = req.userId;
    
    // –ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å —Å–æ–∑–¥–∞—Ç–µ–ª—è —á–∞—Ç–∞
    if (userId === chat.created_by) {
      return res.status(403).json({ error: 'Cannot remove chat creator' });
    }
    
    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± —É–¥–∞–ª—è–µ–º–æ–º —É—á–∞—Å—Ç–Ω–∏–∫–µ
    const participant = await ChatParticipant.findOne({
      where: { chat_id: chat.id, user_id: userId },
      include: [{ model: User, as: 'user' }]
    });
    
    if (!participant) {
      return res.status(404).json({ error: 'Participant not found' });
    }
    
    // –£–¥–∞–ª—è–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞
    const removed = await chat.removeParticipant(userId);
    
    if (!removed) {
      return res.status(404).json({ error: 'Participant not found' });
    }
    
    // –£–≤–µ–¥–æ–º–ª—è–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
    sendToChat(chat.id, 'participant_removed', {
      chat_id: chat.id,
      user: participant.user.getPublicData(),
      removed_by: currentUserId
    });
    
    res.json({
      message: 'Participant removed successfully'
    });
    
    console.log(`üë• User ${participant.user.username} removed from chat ${chat.name}`);
  } catch (error) {
    console.error('Remove participant error:', error);
    res.status(500).json({ error: 'Failed to remove participant' });
  }
});

// –ü–æ–∫–∏–Ω—É—Ç—å —á–∞—Ç
router.post('/:chatId/leave', authenticateToken, checkChatExists, checkChatPermission(), async (req, res) => {
  try {
    const chat = req.chat;
    const userId = req.userId;
    
    // –ù–µ–ª—å–∑—è –ø–æ–∫–∏–Ω—É—Ç—å —á–∞—Ç, –µ—Å–ª–∏ —Ç—ã –µ–≥–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å
    if (userId === chat.created_by) {
      return res.status(403).json({ error: 'Chat creator cannot leave the chat' });
    }
    
    // –£–¥–∞–ª—è–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞
    const removed = await chat.removeParticipant(userId);
    
    if (!removed) {
      return res.status(404).json({ error: 'You are not a participant of this chat' });
    }
    
    // –£–≤–µ–¥–æ–º–ª—è–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
    sendToChat(chat.id, 'participant_left', {
      chat_id: chat.id,
      user: req.user.getPublicData()
    });
    
    res.json({
      message: 'Left chat successfully'
    });
    
    console.log(`üëã User ${req.user.username} left chat ${chat.name}`);
  } catch (error) {
    console.error('Leave chat error:', error);
    res.status(500).json({ error: 'Failed to leave chat' });
  }
});

// –û–±–Ω–æ–≤–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —É—á–∞—Å—Ç–Ω–∏–∫–∞
router.put('/:chatId/settings', authenticateToken, checkChatExists, checkChatPermission(), [
  body('is_muted')
    .optional()
    .isBoolean()
    .withMessage('is_muted must be a boolean'),
  body('is_pinned')
    .optional()
    .isBoolean()
    .withMessage('is_pinned must be a boolean'),
  body('settings')
    .optional()
    .isObject()
    .withMessage('settings must be an object')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        error: 'Validation failed', 
        details: errors.array() 
      });
    }
    
    const participant = req.chatParticipant;
    const { is_muted, is_pinned, settings } = req.body;
    
    const updateData = {};
    if (is_muted !== undefined) updateData.is_muted = is_muted;
    if (is_pinned !== undefined) updateData.is_pinned = is_pinned;
    if (settings !== undefined) {
      updateData.settings = { ...participant.settings, ...settings };
    }
    
    await participant.update(updateData);
    
    res.json({
      message: 'Settings updated successfully',
      settings: {
        is_muted: participant.is_muted,
        is_pinned: participant.is_pinned,
        settings: participant.settings
      }
    });
  } catch (error) {
    console.error('Update participant settings error:', error);
    res.status(500).json({ error: 'Failed to update settings' });
  }
});

module.exports = router;